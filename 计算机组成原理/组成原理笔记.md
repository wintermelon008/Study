## 第一章 计算机系统概论

#### 1.1.1 计算机系统简介

计算机分类：专用计算机（嵌入式系统）、通用计算机（普通PC机）

通用计算机：单片机、微型机、工作站、服务器、大型机、超级计算器

*简易性从高到低，性能从低到高*

中国的第一台计算机：1958 `103型计算机（DJS-1）`

中国第一台通用计算机：1960 `107型计算机`



现代计算机的处理过程：

1. 高级语言程序便携程序，描述问题的求解过程
2. 计算机将其翻译成机器语言程序





#### **1.1.2 计算机系统的层次结构**



#### 1.2.1 计算机硬件组成

**相关设备**

- **存储器**：存放数据和程序
- **运算器**：完成算数运算和逻辑运算，暂存中间结果
- **输入、输出设备**：实现人们熟悉的信息形式和机器能识别的形式之间的转化
- **控制器**：控制、指挥程序和数据的输入、运行以及处理运算结果

冯 · 诺依曼机（以运算器为中心）

- 有上述的五大组成部件
- 数据和指令用二进制数表示，以同等地位存放在存储器中，按地址访问
- 指令由操作码和地址码组成，在存储器中按照顺序存放

*冯 · 诺依曼结构也被称作普林斯顿结构*

*哈佛结构则是将指令和数据分开的结构，较多用在嵌入式系统中*

现代计算机以存储器为中心。运算器和控制器在逻辑关系和短裤结构上联系紧密，将其集成在同一块芯片上，称为中央处理器（CPU）



**运算器（算数逻辑单元 ALU）：**

- 数据格式：二进制数，长度一般为 2 的幂
- 运算器至少包含三个寄存器：`ACC 累加器`、`MQ 乘商寄存器`、`X 操作数寄存器`
- 数据传送：将运算结果从ACC送至MDR；从MDR将源数据送至ACC、MQ、X

|      | 加法       | 减法       | 乘法           | 除法 |
| ---- | ---------- | ---------- | -------------- | ---- |
| ACC  | 被加数、和 | 被减数、差 | 乘积高位       |      |
| MQ   |            |            | 乘积低位、乘数 |      |
| X    | 加数       | 减数       | 被乘数         |      |



**控制器：**

控制计算机各个部件有条不紊地工作

控制器的组成：

- `程序计数器PC`：用于存放当前将要执行的指令，具有自动加一的功能
- `指令寄存器IR`：存放当前CPU执行的指令内容
- `控制单元CU`：根据当前指令发出各种微操作命令序列

控制器周期性完成以下三个过程

1. 取指令：从存储器中按照序列取出一条指令
2. 分析：对指令分析，确定操作码及操作数的地址
3. 执行：根据分析的结果区执行相应的过程



**存储器：**

保存解决问题所需的数据和解题步骤

包括`存储体`、`逻辑部件`及`控制电路`等

- 存储单元按照`字`或`字节`寻址
- 程序和数据顺序存放
- 读写操作以`数据总线宽度`为单位

主存储器的工作方式：

​	按照地址存取方式，配置有MAR、MDR





**I/O 设备：**

输入设备

输出设备

适配器：类似于转换器，实现 I/O 设备



**总线：**

是构成计算机系统的骨架，是计算机各个组成部件之间进行数据传输的通路





## 第二章 指令系统

### 2.1 指令系统的性能要求

#### 2.1.1 指令系统的发展

**指令**：计算机执行某种操作的命令。从计算机组成的层次结构看，指令分为以下几种：

- 微指令：微程序级的命令，属于硬件
- 宏指令：若干条机器指令组成的命令，属于软件
- 机器指令：通常所说的指令，介于微指令和宏指令之前，可完成一个独立的算术运算或逻辑运算操作

**指令系统**：一台计算机所有机器指令的集合，称为该计算机的指令系统。指令系统是表征计算机性能的重要因素。指令的格式和功能直接影响机器的硬件结构，也直接影响系统软件，影响到机器的适用范围。



#### 2.1.2 指令系统的性能要求

##### 四个方面

- **完备性**：指令系统直接提供的指令足够使用，相关功能不需用软件实现

  乘法指令 VS 加法指令

- **有效性**：指令级程序占据的存储空间小，执行速度快，能够高效运行

  访存效率、执行效率

- **规整性**：对称性、匀齐性、指令格式与数据格式的一致性

  变长指令与定长指令

- **兼容性**：向上兼容（低档机器的软件能在高档机器上运行）、向前兼容



##### **常见的语言泛型**

- **过程式范型（Procedural，或称命令式，Imperative）**：

  ​		C，Pascal，Fortran 等 

- **函数式范型（Functional）**：

  ​		最早的函数式语言是John McCarthy 开发的Lisp。目前最重要的函数式语言包括Common Lisp，Scheme，ML 和Haskell 等。

- **面向对象的范型（Object-Oriented）** ：

  - JavaScript，是基于对象的语言，通过原型概念定义新的类似对象
  - 其他支持OO 概念和编程方法的语言包括C++，Ada95 等 
  -  Smalltalk，Java 等基于类的语言，程序中定义类，对象是类的实例

- **说明式语言（Declarative）** ：

  ​		逻辑式语言Prolog；数据库查询语言Datalog

- **脚本语言（Scripting Language）**  

- **文本描述语言 Postscript**，也是一种完整的程序设计语言

- **仪器控制语言 Forth**，是一种完整的基于栈的程序设计语言

- **硬件描述语言 Verilog 和 VHDL** 



### 2.2 指令格式

#### 2.2.1 指令的一般格式

##### **指令格式**

​		指令字用二进制代码表示的结构形式，通常由操作码和地址码两部分组成。

- 操作码：指明指令要完成的操作特性和功能
- 地址码（操作数）：指明参与操作的操作数的存储位置

##### **操作码作用**

- 指明指令要完成的操作，如加法、传送、移位等
- 通过操作码字段的不同编码实现

##### **操作码长度**

​		操作码的位数反映了机器的操作种类，即机器最多允许的指令种类数。操作码包含n位的机器，最多能够有$2^n$种指令。如操作码占7位，则该机器最多包含$2^7$=128种指令

##### **扩展操作码技术**

- 操作码长度随指令字中地址数的变化而变化
- 尽可能以较短的指令字长表示较多的操作种类

##### **变长操作码设计原则**

​		尽量安排使用频度较高的指令占用短的操作码，使用频度低的指令占用长的操作码，以加速常用指令的译码分析

##### **地址码**

​		指出指令的源操作数的地址（一个或两个）、结果的地址或者下一条指令的地址。这里的 “地址” ，可以是主存地址、寄存器地址、I/O设备地址等 

##### **按操作数物理位置对指令分类**

1. 存储器-存储器（SS）型指令

   操作数都存放在主存中，指令执行过程需多次访问主存

2. 寄存器-寄存器（RR）型指令

   操作数都存放在CPU的寄存器中，指令执行过程需使用到多个通用寄存器或个别专用寄存器，执行速度相对较快。RISC型指令系统中，多数指令都设计为此种类型。

3. 寄存器-存储器（RS）型指令

   操作数可能存放在寄存器或存储器中



#### 2.2.2 指令字长

##### **指令字长**

​		指一个指令字中包含的二进制代码的位数。其取决于操作码长度、操作数地址的长度和操作数地址的个数。

##### 指令字长与机器字长的关系

1. **指令字长等于机器字长时——单字长指令**

   早期机器中，存储字长也与两者相等，一次访存可以取出一条完整指令或数据

2. **指令字长等于机器字长的一半——半字长指令**

3. **指令字长等于机器字长的两倍/多倍——双/多字长指令**

   为了能够提供足够的地址位以解决访问内存任意单元的寻址问题需多次内存访问才能取出一条完整指令，CPU速度降低，占用更多存储空间



#### 2.2.3 指令助记符

##### **指令助记符**

​		由于二进制码0和1用于书写和阅读程序十分麻烦，常用3个或4个英文缩写来表示指令，这种缩写码叫做指令助记符。不同计算机指令系统的指令助记符的规定是不一样的。

​		助记符到二进制操作码的转换——汇编程序（汇编器）



### 2.3 操作数与操作类型

#### 2.3.1 操作数类型

##### 计算机中常见的操作数类型

1. 地址：被看做一个无符号整数

   ​		很多情况下，对指令中的操作数的引用必须完成某种计算，才能确定其在主存中的有效地址。

2. 数值：定点数、浮点数、十进制数等

3. 字符：文本或字符串

   ​		普遍采用ASCII字符编码，以8位的字节来存储和传送字符。其他的一些字符编码，如8位EBCDIC（扩展BCD交换码）

4. 逻辑数据

   ​		存储单元中的每一位“0”或“1”都代表真或假的布尔型值，这些 0和1组合的数就被看做逻辑数，能够对某个具体位进行逻辑运算。



#### 2.3.2 数据在存储器中的存储方式

##### **关于数据存储的要求**

​		数据存放在存储器或寄存器中，寄存器位数反映机器字长。数据在存储器中一般是以字节（8位）为最小单位来存储。对数据的访问，可以按字节、半字、字或者双字进行

##### **边界对齐问题**

​		多字节的数据，在存储时需要“边界对齐”。否则会出现因数据的访问方式而引发的存储限制。

**数据不做边界对齐带来的问题：读取一个数据时，可能需要两次访存操作才能取到完整的数据，降低了CPU的处理速度。**



<img src="D:\mygit\计算机组成原理\pictures\2.3.2.png" alt="image-20220316143955431"  />

##### 字节顺序问题

小尾端和大尾端的方式：按照低地址存储的是低位还是高位进行区分

```c
int test = 1;
char *ch = (char*)(test);
if (*ch == 1) {
	//为大尾端（低位在高地址）
}
else {
	//为小尾端（低位在低地址）
}
```





#### 2.3.3 操作类型

##### 计算机指令系统的操作类型

​		不同的机器，指令系统不尽相同，所支持的操作类型也就不同.但几乎所有机器都会具有一些通用的操作：数据传送、算术逻辑运算、移位、跳转等 。

- **数据传送操作**

  ​		出现在寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间。典型的操作：存储器读取LOAD和存入STORE；从源到目的的传送MOVE；进栈PUSH、出栈POP等。

- **算术逻辑操作**

  ​		实现算术运算和逻辑运算。一般机器都支持基本的二进制加减、比较等，有些支持浮点运算和十进制运算。有些机器还支持位操作功能，如位测试、位清除、位求反等。

- **移位操作**

  ​		分算术移位（有符号）、逻辑移位（无符号）、循环移位。算数移位常被用来代替简单的乘法和除法运算——左移 n 位：乘以$2^n$；右移 n 位，除以$2^n$

- **转移跳转操作**

  ​		一般情况下，计算机顺序执行指令，可以通过转移类指令改变。转移类指令(控制指令)包括：无条件转移、条件转移、过程调用与返回、陷阱等。

  1. 无条件转移：不受条件约束，直接把程序转移到指定的下一条指令位置继续执行。
  2. 条件转移：根据当前指令的执行结果来判断条件是否满足，从而决定是否进行转移。
  3. 调用与返回：将一些特定的功能编写成独立的子程序，当程序中需要该功能时，通过调用指令进行调用，执行完后返回。
  4. 陷阱：一种意外事故中断，如除0、运算溢出等。一般不提供给用户直接使用，而作为隐含指令由CPU在出现，在意外时自动产生并执行。也有机器设置供用户使用的陷阱指令，利用它来完成系统调用和程序请求，如IBM PC (Intel 8086)的软中断INT TYPE。

- **输入输出操作**

  ​		对于I/O独立编址的计算机，通过此类指令完成从外设中取数据和将数据输出到某个外设的操作。

- **其他操作**

  1. 控制类：等待指令、停机指令、空指令、开/关中断指令等
  2. 字符串传送、比较、查询及转换等
  3. 向量指令





### 2.4 寻址方式

##### 地址

​		操作数或指令存放在某个存储单元时，该存储单元的编号，称为该操作数或指令在存储器中的地址。

##### 寻址方式

​		确定本条指令中的数据地址以及下一条将要执行的指令地址的方法。与硬件结构紧密相关，直接影响指令格式和指令性能。

寻址方式分为指令寻址和数据寻址两类：

- 前者简单，后者复杂
- 在冯·诺依曼型计算机中，指令寻址和数据寻址交替执行



#### 2.4.1 指令寻址

##### **指令寻址**

​		分为顺序寻址和跳跃寻址两种。

- **顺序寻址**

  ​		通过程序计数器 PC 加1(+4…)，自动形成下一条指令的地址

- **跳跃寻址**

  ​		由当前指令（转移类指令）的地址码域给出下一条指令的地址。跳跃后按新的指令地址再顺序寻址，直到又碰到转移类指令。可以以此实现程序转移或构成循环程序。



#### 2.4.2 数据寻址

##### 数据寻址

​		形成数据的有效地址的方法，称为数据的寻址方式。

- 形式地址A：指令的地址码字段所表示的地址，通常不代表操作数的真实地址。
- 有效地址EA：相对于形式地址而言，是操作数的真实地址，由寻址特征和形式地址共同确定。

##### **寻址特征字段**

 		用于确定指令的操作数据应使用何种寻址方式。包括间接寻址位 + 变换寻址位 + 其他寻址位

> **数据寻址过程，就是把操作数的形式地址，通过寻址特征，变换为操作数的有效地址的过程。**

<img src="D:\mygit\计算机组成原理\pictures\2.4.2p1.png" alt="image-20220316145858911" style="zoom: 80%;" />





### 2.5 CISC 与 RISC

##### **指令集结构功能设计方向**

- **一个方向是强化指令功能，实现软件功能向硬件功能转移，基于这种指令集结构而设计实现的计算机系统称为复杂指令集计算机（CISC）。**
- **另一个方向是八十年代发展起来的精简指令集计算机（RISC），其目的是尽可能地降低指令集结构的复杂性，以达到简化实现，提高性能的目的。**

#### 2.5.1 CISC 技术

```
Complex Instruction Set Computer——复杂指令集计算机
形成原因
• 早期计算机部件昂贵，主频低，运算慢；
• 为提高速度，将越来越多的复杂指令加入到指令系统中
特点
• 指令系统庞大，指令功能丰富
• 指令格式和寻址方式较多，多数指令需多个指令周期完成
• 各种指令都可以访问存储器，少量的专用寄存器
• 通过复杂化硬件来简化软件实现
相关技术
• 操作码扩展
• 各种寻址方式
```

##### 面向目标程序增强指令功能

- 提高运算型指令功能；
- 提高传送指令功能；
- 增加程序控制指令功能。

##### 面向操作系统和编译程序改进指令系统

- 主要表现在对中断处理、进程管理、存储管理和保护、系统工作状态的建立与切换、进程同步和互斥等的支持；
- 增加对编译系统支持的指令功能。

##### CISC结构存的缺点

1. **在CISC结构的指令系统中，各种指令的使用频率相差悬殊。据统计，有20％的指令使用频率最大，占运行时间的80％。也就是说，有80％的指令在20％的运行时间内才会用到。** 
2. **CISC结构指令系统的复杂性带来了计算机体系结构的复杂性，这不仅增加了研制时间和成本，而且还容易造成设计错误。CISC结构指令系统的复杂性给VLSI设计增加很大负担，不利于单片集成。许多指令需要很复杂的操作，因而运行速度慢。**
3.  **在CISC结构的指令系统中，由于各条指令的功能不均衡，不利于采用先进的计算机体系结构技术（如流水技术）来提高系统的性能。**



#### 2.5.2 RISC 技术

```
Reduced Instruction Set Computer—精简指令集计算机
 形成原因
• “二八”定律，VLSI技术的发展
• 1975年，IBM的John Cocke提出了精简指令系统的设想
 特点
• 指令系统简单、规则(所有指令长度均相同,在一个机器周期内完成) • 只选取实现使用频率较高的一些简单指令
• 复杂功能通过简单指令的组合来实现
• 指令字长固定，指令格式种类少，寻址方式少
• 只有取数/存数指令访问存储器，其余指令的操作在寄存器间进行
• 寄存器数目相对较多
 相关技术
• 流水线技术、超标量技术
```

##### **RISC指令集功能设计原则**

1. **选取使用频率最高的指令，并补充一些最有用的指令；**
2. **每条指令的功能应尽可能简单，并在一个机器周期内完成；**
3. **所有指令长度均相同；**
4. **只有load和store操作指令才访问存储器，其它指令操作均在寄存器之间进行。**



#### 2.5.3 二者的比较

![image-20220316151138717](D:\mygit\计算机组成原理\pictures\2.5.3.png)



### 2.6 指令系统设计与举例

#### 2.6.1 简单指令集

#### 2.6.2 MIPS 指令集

#### 2.6.3 x86 指令集

#### 2.6.4 RISC-V 指令集

