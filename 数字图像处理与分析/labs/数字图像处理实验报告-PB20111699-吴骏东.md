## **《数字图像处理与分析》实验** 

> **PB20111699 吴骏东**
>
> **2022.5**

**实验学时**：20 学时 

**实验目的：**本实验的目的是通过实验进一步理解和掌握数字图像处理与分析的原理和方法。通过分析、实现现有的图像处理算法，学习和掌握常用的图像处理与分析技术。

**实验内容：**数字图像处理的实验内容主要包括五个方面: （1）图像几何变换。（2）对图像进行空间域滤波，提高图像视觉质量, 以便于人眼观察、理解或用计算机对其进一步处理。（3） 对图像作频域变换, 进行频率域滤波增强处理。（4）在空间域和频域提取、描述和分析图像中所包含的特征,便于计算机对图像作进一步的分析和理解, 经常作为模式识别和计算机视觉的预处理。这些特征包括很多方面,如图像的频域特性、边界特征等。 （5）了解常见的图像退化模型和相应的图像恢复算法，从本质上改善图像质量；对图像进行分析，采用阈值法、区域分裂合并法等分割算法，获取图像中感兴趣目标区域。



### 实验一 图像几何变换

#### 1.1 图像的平移

​		图像平移就是将图像中所有的点都按照指定的平移量水平、垂直移动。如：设$(x_0 , y_0 )$为原图像的一点，图像水平平移量为 $t_x$,垂直平移量为 $t_y$,则平移后坐标变为$(x_1, y_1)$，显然，$(x_0 , y_0 )$和$(x_1, y_1)$有如下关系：
$$
\left\{
\begin{aligned}
x_1 = x_0 + t_x \\
y_1 = y_0 + t_y \\
\end{aligned}
\right.
$$
​		用矩阵表示如下：
$$
\begin{bmatrix}
x_1 \\
y_1\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & t_x \\
0 & 1 & t_y \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x_0 \\
y_0\\
1\\
\end{bmatrix}
$$
**要求：输入一幅图像，根据输入的水平和垂直平移量，显示平移后的图像。**

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 1-1

string = input("请输入平移偏移量 dx and dy\n(用逗号分隔)\n", 's');
in = strsplit(string, ',');
dx = str2num(in{1});
dy = str2num(in{2});

origin = imread("./pics/lena.bmp");
moved = imtranslate(origin, [dx, dy]);

figure();
subplot(1, 2, 1);
imshow(origin);
title("Origin Lana");

subplot(1, 2, 2);
imshow(moved);
title("Moved Lana");
```

##### 调用的函数

- imread 图像读取函数
- imtranslate(A, [dx, dy]) 图像平移函数：在原结构元素上 y 和 x 方向平移
- figure 创建窗口函数
- imshow 图像显示函数

##### 结果展示

```matlab
请输入平移偏移量 dx and dy
(用逗号分隔)
50, 100
```

<img src="pics\1-1.png" alt="image-20220502144726600" style="zoom: 67%;" />



#### 1.2 图像的旋转

​		图像绕中心点（原点）旋转的公式如下：
$$
\begin{bmatrix}
x_1 \\
y_1\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x_0 \\
y_0\\
1\\
\end{bmatrix}
$$
​		图像如果绕一个指定点$(a, b)$旋转，则先要将坐标系平移到该点，再进行旋转，然后z平移回新的坐标原点。则旋转变换表达式为：
$$
\begin{bmatrix}
x_1 \\
y_1\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & a \\
0 & 1 & b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & -a \\
0 & 1 & -b \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x_0 \\
y_0\\
1\\
\end{bmatrix}
$$
**要求：输入一幅图像，根据输入的旋转角度参数，绕图像中心点旋转，分别用最近邻插值和双线性插值显示旋转后的图像。**

##### **实验代码**

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 1-2

angle = input("请输入旋转角度\n(取逆时针为正方向, 用角度制)\n");
disp(angle);

origin = imread("./pics/lena.bmp");
rotate_nearist = imrotate(origin, angle, 'nearest');
rotate_bilinear = imrotate(origin, angle, 'bilinear');

figure();
subplot(1, 3, 1);
imshow(origin);
title("Origin Lana");

subplot(1, 3, 2);
imshow(rotate_nearist);
title("Nearist");

subplot(1, 3, 3);
imshow(rotate_bilinear);
title("Bilinear");
```

##### 调用的函数

- imrotate (I,angle,method,bbox)

```
angle决定旋转的角度
method属于{，，}，决定插值方式
    ‘nearest’:最近邻插值，为默认值。
    ‘bilinear’:双线性插值。
    ‘bicubic’:双三次插值。输出像素值是最近的 4×4 邻域中像素的加权平均值。
 bbox 参数来定义输出图像的大小。
    ‘crop’使输出图像 J 与输入图像 I 大小相同，裁剪旋转后的图像以适应边界框。
    ‘loose’:使输出图像 J 足够大，以包含整个旋转后的图像。J 大于 I。为默认值
```

##### 结果展示

```matlab
请输入旋转角度
(取逆时针为正方向, 用角度制)
-60
   -60
```

<img src="pics\1-2.png" alt="image-20220502145332675" style="zoom:67%;" />



#### 1.3 图像的缩放

​		假设图像 x 轴方向缩放比率为 c, y 轴方向缩放比率为 d, 那么原图中，点$(x_0, y_0)$对应于新图中的点$(x_1, y_1)$的转换矩阵为：
$$
\begin{bmatrix}
x_1 \\
y_1\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
c & 0 & 0 \\
0 & d & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
x_0 \\
y_0\\
1\\
\end{bmatrix}
$$
**要求：输入一幅图像，根据输入的水平和垂直缩放量，分别用最近邻插值和双线性插值，显示缩放后的图像。**

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 1-3

string = input("请输入长宽伸缩比例 c and d\n(用逗号分隔, 数值大于一为放大)\n", 's');
in = strsplit(string, ',');
c = str2num(in{1});
d = str2num(in{2});

origin = imread("./pics/lena.bmp");
[h, w, c] = size(origin);
resize_nearist = imresize(origin, [h*c, w*d], 'nearest');
resize_bilinear = imresize(origin, [h*c, w*d], 'bilinear');


figure();
subplot(1, 3, 1);
imshow(origin);
title("Origin Lana");

subplot(1, 3, 2);
imshow(resize_nearist);
title("Nearist");

subplot(1, 3, 3);
imshow(resize_bilinear);
title("Bilinear");
```

##### 调用的函数

- imresize (I,scale) 返回图像 J。它是将 I 的长宽大小缩放 scale 倍之后的图像。输入图像 I 可以是灰度图像、RGB 图像、二值图像或分类图像；

  imresize(I,[numrows numcols]) 返回图像 J，其行数和列数由向量 [numrows numcols] 指定；

  imresize(___,method) 指定使用的插值方法。

##### 结果展示

```matlab
请输入长宽伸缩比例 c and d
(用逗号分隔, 数值大于一为放大)
1, 2
```

<img src="pics\1-3.png" alt="image-20220502145817275" style="zoom:67%;" />



#### 1.4 图像几何失真校正

**要求：输入图像 alphabet1.jpg 及几何失真图像 alphabet2.jpg，设置控制点进行几何失真校正，显示校正后的图像。**

实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 1-4

origin = imread("./pics/alphabet2.jpg");
right = imread("./pics/alphabet1.jpg");

figure();
subplot(1, 2, 2);
imshow(right);
title("标准图像");

subplot(1, 2, 1);
imshow(origin);
title("变形图像");
text(160, -70,'请在变形图像中选取第一个点');
[x1, y1] = ginput(1);
delete(findobj('type','text'));

text(160, -70,'请在标准图像中选取对应点');
[x2, y2] = ginput(1);
delete(findobj('type','text'));

text(-160, -70,'请在变形图像中选取第二个点');
[x3, y3] = ginput(1);
delete(findobj('type','text'));

text(160, -70,'请在标准图像中选取对应点');
[x4, y4] = ginput(1);
delete(findobj('type','text'));

text(-160, -70,'请在变形图像中选取第三个点');
[x5, y5] = ginput(1);
delete(findobj('type','text'));

text(160, -70,'请在标准图像中选取对应点');
[x6, y6] = ginput(1);
delete(findobj('type','text'));

text(-160, -70,'请在变形图像中选取第四个点');
[x7, y7] = ginput(1);
delete(findobj('type','text'));

text(160, -70,'请在标准图像中选取对应点');
[x8, y8] = ginput(1);
delete(findobj('type','text'));
% 用户输入完成

Origin_points = [x1 y1; x3 y3; x5 y5; x7 y7];
Correct_points = [x2 y2; x4 y4; x6 y6; x8 y8];
Transform = fitgeotrans(Origin_points, Correct_points, 'projective');
after_image = imwarp(origin, Transform, 'bilinear');

close all;
figure();
subplot(1, 2, 1);
imshow(origin);
title("原始图像");

subplot(1, 2, 2);
imshow(uint8(after_image));
title("修复图像");
```

##### 调用的函数

- fitgeotrans：几何变换拟合函数
- imwarp：几何变换函数

##### 结果展示

​		选取变形图像四个顶点作为参考点，恢复效果如下：

<img src="pics\1-4.png" alt="image-20220502150217794" style="zoom: 33%;" />





### 实验二 图像点处理增强

#### 2.1 灰度的线性变换

​		灰度的线性变换就是将图像中所有的点的灰度按照线性灰度变换函数进行变换。该线性灰度变换函数是一个一维线性函数：
$$
f(x) = f_A\cdot x + f_B
$$
 		灰度变换方程为：
$$
D_B = f(D_A) = f_A\cdot D_A + f_B
$$
​		其中参数 $f_A$为线性函数的斜率， $f_B$ 为线性函数的在 y 轴的截距， $D_A$ 表示输入图像的灰度，$D_B$ 表示输出图像的灰度。

**要求：输入一幅图像，根据输入的斜率和截距进行线性变换，并显示。**

##### **实验代码**

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 2-1

string = input("请输入斜率 fa 与截距 fb \n(用逗号分隔)\n", 's');
in = strsplit(string, ',');
fa = str2num(in{1});
fb = str2num(in{2});

lena = imread("./pics/lena.bmp");

[m, n] = size(lena); 
moved = zeros(m, n);
for i = 1 : m
    for j = 1 : n
        temp = lena(i, j) * fa + fb;
        if (temp < 0)
            temp = 0;
        elseif (temp > 255)
            temp = 255;
        end
        moved(i, j) = temp;
    end
end

figure();
subplot(1, 2, 1);
imshow(lena);
title("Lana 原始图");

subplot(1, 2, 2);
imshow(uint8(moved));
title("Lana 灰度变换图");
```

##### 调用的函数

- 无

##### 结果展示

```matlab
请输入斜率 fa 与截距 fb 
(用逗号分隔)
2, 1
```

<img src="pics\2-1.png" alt="image-20220502150812569" style="zoom: 67%;" />





#### 2.2 灰度拉伸

​		灰度拉伸和灰度线性变换相似。不同之处在于它是分段线性变换。表达式如下：
$$
f(x) = \left\{
\begin{aligned}
\frac{y_1}{x_1}x, \qquad\qquad\ \ \ \qquad\qquad\qquad x < x_1\\
\frac{y_2-y_1}{x_2-x_1}(x-x_1) + y_1, \quad x_1 \le x \le x_2 \\
\frac{255-y_2}{255-x_2}(x-x_2) + y_2, \quad\qquad x > x_2
\end{aligned}
\right.
$$
​		其中，$(x_1, y_1)$ 和$(x_2, y_2)$ 是分段函数的转折点。

 **要求：输入一幅图像，根据选择的转折点，进行灰度拉伸，显示变换后的图像。**

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 2-2

string = input("请输入第一个转折点坐标 x1, y1 \n(用逗号分隔)\n", 's');
in = strsplit(string, ',');
x1 = str2num(in{1});
y1 = str2num(in{2});
string = input("请输入第二个转折点坐标 x2, y2 \n(用逗号分隔)\n", 's');
in = strsplit(string, ',');
x2 = str2num(in{1});
y2 = str2num(in{2});

if (x1 == 0)
    x1 = 1;
elseif (x2 == 0)
    x2 = 1;
elseif (x1 == 255)
    x1 = 254;
elseif (x2 == 255)
    x2 = 254;
end

lena = imread("./pics/lena.bmp");

[m, n] = size(lena); 
moved = zeros(m, n);
for i = 1 : m
    for j = 1 : n
        if (lena(i, j) < x1)
            temp = y1 / x1 * lena(i, j);
        elseif (lena(i, j) < x2)
            temp = (y2 - y1)/(x2 - x1) * (lena(i, j) - x1) + y1;
        else
            temp = (255 - y2) / (255 - x2) * (lena(i, j) - x2) + y2;
        end
                
        temp = round(temp);
        if (temp < 0)
            temp = 0;
        elseif (temp > 255)
            temp = 255;
        end
        moved(i, j) = temp;
            
    end
end

figure();
subplot(1, 2, 1);
imshow(lena);
title("Lana 原始图");

subplot(1, 2, 2);
imshow(uint8(moved));
title("Lana 灰度拉伸图");
```

##### 调用的函数

- 无

##### 结果展示

```matlab
请输入第一个转折点坐标 x1, y1 
(用逗号分隔)
50, 100
请输入第二个转折点坐标 x2, y2 
(用逗号分隔)
150, 250
```

<img src="pics\2-2.png" alt="image-20220502151413571" style="zoom: 67%;" />



#### 2.3 灰度直方图

​		灰度直方图是灰度值的函数，描述的是图像中具有该灰度值的像素的个数，其横坐标表示像素的灰度级别，纵坐标表示该灰度出现的频率(象素的个数)。

**要求：输入一幅图像，显示它的灰度直方图，可以根据输入的参数（上限、下限）显示特定范围的灰度直方图。**

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 2-3

string = input("请输入灰度直方图的下限 min 与上限 max \n(用逗号分隔)\n", 's');
in = strsplit(string, ',');
min = str2num(in{1});
max = str2num(in{2});

lena = imread("./pics/lena.bmp");
[counts, bins] = imhist(lena);

new_bins = zeros(max - min + 1: 1);
new_counts = zeros(max - min + 1: 1);
for i = 1: max - min + 1
    new_bins(i, 1) = i + min - 1;
    new_counts(i, 1) = counts(i + min, 1);
end

figure();
subplot(1, 2, 1);
imshow(lena);
title("Lana 原始图");
subplot(1, 2, 2);
bar(new_bins, new_counts);
title("Lana 灰度直方图");
```

##### **调用的函数**

- imhist ( )

```
[counts,binLocations] = imhist(I,n)，指定用于计算直方图的 bin 的数量 n，灰度图默认为256.
[counts,binLocations] = imhist(X,map) 计算具有颜色图 map 的索引图像 X 的直方图。对于颜色图中的每个条目，直方图中都有一个对应的 bin。
```

##### 结果展示

```matlab
请输入灰度直方图的下限 min 与上限 max 
(用逗号分隔)
0,255
```

<img src="pics\2-3_1.png" alt="image-20220502181623014" style="zoom:67%;" />

```matlab
请输入灰度直方图的下限 min 与上限 max 
(用逗号分隔)
100,110
```

<img src="pics\2-3_2.png" alt="image-20220502181714955" style="zoom: 67%;" />

 

#### 2.4 直方图均衡

**要求：**

1. **显示一幅图像 pout.bmp 的直方图；**
2. **用直方图均衡对图像 pout.bmp 进行增强；**
3. **显示增强后的图像及其直方图；**
4. **用原始图像 pout.bmp 进行直方图规定化处理，将直方图规定化为高斯分布；**
5. **显示规定化后的图像及其直方图。**

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 2-4

pout = imread("./pics/pout.bmp");
[counts, bins] = imhist(pout);
%J_pout = imadjust(pout, [0.3, 0.7], [0, 1]);
J_pout = histeq(pout, 256);
[J_counts, J_bins] = imhist(J_pout);

% 计算高斯直方图
G_bins = zeros(256, 1);
G_counts = zeros(256, 1);
x = 1: 1: 255;
y = Gaussian(x, 127, 40);
y = y * 30000;
y = round(y) + 100;

G_pout = histeq(pout, y);
[G_counts, G_bins] = imhist(G_pout);

figure();
subplot(3, 2, 1);
imshow(pout);
title("Pout 原始图");
subplot(3, 2, 2);
bar(bins, counts);
title("Pout 灰度直方图");
subplot(3, 2, 3);
imshow(J_pout);
title("Pout 增强图");
subplot(3, 2, 4);
bar(J_bins, J_counts);
title("Pout 增强灰度直方图");
subplot(3, 2, 5);
imshow(G_pout);
title("Pout 高斯规定化图");
subplot(3, 2, 6);
bar(G_bins, G_counts);
title("Pout 高斯规定化灰度直方图");

function [y] = Gaussian(x, mu, sigma)
y = 1/(sqrt(2*pi)*sigma)*exp(-(x-mu).^2/(2*sigma^2));
end
```

##### 用到的函数

- imadjust (I,[low_in high_in],[low_out high_out],gamma)：将 I 中的强度值映射到 J 中的新值，其中 gamma 指定描述 I 和 J 中的值之间关系的曲线形状。

```
如果 gamma 小于 1，则 imadjust 会对映射加权，使之偏向更高（更亮）输出值。
如果 gamma 大于 1，则 imadjust 会对映射加权，使之偏向更低（更暗）输出值。
如果 gamma 是 1×3 向量，则 imadjust 会对每个颜色分量或通道分别应用不同的 gamma。
如果省略该参数，则 gamma 取默认值 1（线性映射）。
```

- Gaussian ( )：高斯函数

##### 结果展示

<img src="D:\2022春\数字图像\exp\pics\2-4.png" alt="image-20220502182040949" style="zoom: 50%;" />





### 实验三 图像空间域滤波增强

**实验内容及实验原理：**

1． 用均值滤波器（即邻域平均法）去除图像中的噪声；

2． 用超限邻域平均法去除图像中的噪声；

3． 用中值滤波器去除图像中的噪声； 

4． 用超限中值滤波器去除图像中的噪声；

5． 比较四种方法的处理结果。 

6．利用常用的边缘检测算子提取图像边缘

**要求：**

1. **用原始图像 lena.bmp 或 cameraman.bmp 分别加产生的 3%椒盐噪声、高斯噪声、随机噪声合成有噪声的图像并显示；**
2. **用均值滤波器去除图像中的噪声（选 3x3 窗口）；**
3. **用超限邻域平均法去除图像中的噪声（如果某个像素的灰度值大于其邻域像素的平均值，且达到了一定水平，则判断该像素为噪声，继而用邻域像素的均值取代这一像素值）；**
4. **用中值滤波器去除图像中的噪声(选 3x3 窗口做中值滤波)；**
5. **用超限中值滤波器去除图像中的噪声（当某个像素的灰度值超过窗口中像素灰度值排序中间的那个值，且达到一定水平时，则判断该点为噪声，用灰度值排序中间的那个值来代替；否则还是保持原来的灰度值）；**
6. **边缘检测主要有以下几种常用的算子：**

> ​		Roberts 算子
>
> ​		Sobel 算子
>
> ​		Prewitt 算子
>
> ​		拉普拉斯算子
>
> ​		Canny 算子

​	**对 blood.bmp、 lena.bmp，分别用前面所述的算子进行边缘检测，显示边缘检测结果图像。**

#### PART I 噪声与滤波

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 3 PART I
% noise 

lena = imread("./pics/lena.bmp");
[m, n] = size(lena);

% 产生均匀分布矩阵
y = uint8(floor(rand(m, n) * 255));

lena_salt = imnoise(lena,'salt & pepper',0.03);
lena_gauss = imnoise(lena,'gaussian', 0, 0.01);

z = uint8(xor(lena ,lena_salt));
z1 = uint8(~z);
% 添加随机噪声
lena_random = z1 .* lena + z .* y;


% 均值滤波
lena_salt_average  = filter2(fspecial('average',3), lena_salt);
lena_gauss_average  = filter2(fspecial('average',3), lena_gauss);
lena_random_average  = filter2(fspecial('average',3), lena_random);

% 阈限均值滤波
% 设置阈限为 35
T = 35;
lena_salt_dooraverage = lena_salt;
lena_gauss_dooraverage = lena_gauss;
lena_random_dooraverage = lena_random;
for i = 1: m
    for j = 1 : n
        z_salt = get_average(lena_salt, i, j, 1, m, n);
        if abs(int16(z_salt) - int16(lena_salt(i, j))) > int16(T)
            % 超出阈限
            lena_salt_dooraverage(i, j) = uint8(z_salt);
        end
        
        z_gauss = get_average(lena_gauss, i, j, 1, m, n);
        if abs(int16(z_gauss) - int16(lena_gauss(i, j))) > int16(T)
            % 超出阈限
            lena_gauss_dooraverage(i, j) = uint8(z_gauss);
        end
        
        z_random = get_average(lena_random, i, j, 1, m, n);
        if abs(int16(z_random) - int16(lena_random(i, j))) > int16(T)
            % 超出阈限
            lena_random_dooraverage(i, j) = uint8(z_random);
        end
    end
end


figure();
subplot(3, 4, 1);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 2);
imshow(uint8(lena_salt));
title("Lena 3% 椒盐噪声");

subplot(3, 4, 3);
imshow(uint8(lena_gauss));
title("Lena 高斯噪声");

subplot(3, 4, 4);
imshow(uint8(lena_random));
title("Lena 随机噪声");

subplot(3, 4, 5);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 6);
imshow(uint8(lena_salt_average));
title("Lena 3% 椒盐噪声（均值滤波）");

subplot(3, 4, 7);
imshow(uint8(lena_gauss_average));
title("Lena 高斯噪声（均值滤波）");

subplot(3, 4, 8);
imshow(uint8(lena_random_average));
title("Lena 随机噪声（均值滤波）");

subplot(3, 4, 9);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 10);
imshow(uint8(lena_salt_dooraverage));
title("Lena 3% 椒盐噪声（超限均值滤波）");

subplot(3, 4, 11);
imshow(uint8(lena_gauss_dooraverage));
title("Lena 高斯噪声（超限均值滤波）");

subplot(3, 4, 12);
imshow(uint8(lena_random_dooraverage));
title("Lena 随机噪声（超限均值滤波）");

% 邻域均值计算
function ave = get_average(C, x, y, r, m, n)
    ave = C(x, y);
    sum = 0;
    for i = -r : r : 1
        for j = -r : r : 1
            if x + i < 1 || x + i > m || y + j < 1 || y + j > n
                return;
            end
            sum = sum + int16(C(x + i, y + j));
        end
    end
    ave = floor(sum / (2 * r + 1)^2);
    return;
end
```

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 3 PART II
% noise 


lena = imread("./pics/lena.bmp");
[m, n] = size(lena);

% 产生均匀分布矩阵
y = uint8(floor(rand(m, n) * 255));

lena_salt = imnoise(lena,'salt & pepper',0.03);
lena_gauss = imnoise(lena,'gaussian', 0, 0.01);

z = uint8(xor(lena ,lena_salt));
z1 = uint8(~z);
% 添加随机噪声
lena_random = z1 .* lena + z .* y;



% 中值滤波
lena_salt_middle  = medfilt2(lena_salt,[3 3]);
lena_gauss_middle  = medfilt2(lena_gauss,[3 3]);
lena_random_middle  = medfilt2(lena_random,[3 3]);

% 阈限中值滤波
% 设置阈限为 35
T = 35;
lena_salt_doormiddle = lena_salt;
lena_gauss_doormiddle = lena_gauss;
lena_random_doormiddle = lena_random;
for i = 1: m
    for j = 1 : n
        z_salt = get_middle(lena_salt, i, j, 1, m, n);
        if abs(int16(z_salt) - int16(lena_salt(i, j))) > int16(T)
            % 超出阈限
            lena_salt_doormiddle(i, j) = uint8(z_salt);
        end
        
        z_gauss = get_middle(lena_gauss, i, j, 1, m, n);
        if abs(int16(z_gauss) - int16(lena_gauss(i, j))) > int16(T)
            % 超出阈限
            lena_gauss_doormiddle(i, j) = uint8(z_gauss);
        end
        
        z_random = get_middle(lena_random, i, j, 1, m, n);
        if abs(int16(z_random) - int16(lena_random(i, j))) > int16(T)
            % 超出阈限
            lena_random_doormiddle(i, j) = uint8(z_random);
        end
    end
end


figure();
subplot(3, 4, 1);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 2);
imshow(uint8(lena_salt));
title("Lena 3% 椒盐噪声");

subplot(3, 4, 3);
imshow(uint8(lena_gauss));
title("Lena 高斯噪声");

subplot(3, 4, 4);
imshow(uint8(lena_random));
title("Lena 随机噪声");

subplot(3, 4, 5);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 6);
imshow(uint8(lena_salt_middle));
title("Lena 3% 椒盐噪声（中值滤波）");

subplot(3, 4, 7);
imshow(uint8(lena_gauss_middle));
title("Lena 高斯噪声（中值滤波）");

subplot(3, 4, 8);
imshow(uint8(lena_random_middle));
title("Lena 随机噪声（中值滤波）");

subplot(3, 4, 9);
imshow(lena);
title("Lena 原始图");

subplot(3, 4, 10);
imshow(uint8(lena_salt_doormiddle));
title("Lena 3% 椒盐噪声（超限中值滤波）");

subplot(3, 4, 11);
imshow(uint8(lena_gauss_doormiddle));
title("Lena 高斯噪声（超限中值滤波）");

subplot(3, 4, 12);
imshow(uint8(lena_random_doormiddle));
title("Lena 随机噪声（超限中值滤波）");

% 邻域中值计算
function mid = get_middle(C, x, y, r, m, n)
    mid = C(x, y);
    for i = -r : r : 1
        for j = -r : r : 1
            if x + i < 1 || x + i > m || y + j < 1 || y + j > n
                return;
            end
        end
    end
    S = sort(C(x-r : x+r, y-r : y+r));
    mid = S(r + 1, r + 1);
    return;
end
```

##### **用到的函数**

- imfilter (A,h,options,...) ：根据一个或多个指定的选项)使用多维滤波器 h 对多维数组 A 进行滤波。
- fspecial (type) ：创建具有指定 type 的二维滤波器 h。一些滤波器类型具有可选的附加参数，如以下语法所示。fspecial 以相关性核形式返回 h，该形式适用于 imfilter。

##### 结果展示

![image-20220502183418169](pics\3-1.png)

![image-20220502183517090](pics\3-2.png)

结论：对于椒盐和随机噪声，中值滤波效果更好，对于高斯噪声，均值滤波更好。超限滤波比普通滤波更好。



#### PART II 边缘检测

##### 实验代码

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 3 PART III
% edge 

blood = imread("./pics/blood.bmp");
[m, n] = size(blood);

blood_roberts = edge(blood, 'Roberts');
blood_sobel = edge(blood, 'Sobel');
blood_prewitt = edge(blood, 'Prewitt');
blood_canny = edge(blood, 'Canny');

filter_laplacian_1 = [0 1 0; 1 -4 1; 0 1 0];
filter_laplacian_2 = [-1 -1 -1; -1 8 -1; -1 -1 -1];

blood_laplacian_1 = imfilter(blood, filter_laplacian_1);
blood_laplacian_2 = imfilter(blood, filter_laplacian_2);

figure();
subplot(2, 4, 1);
imshow(blood);
title("Blood 原始图");

subplot(2, 4, 2);
imshow((blood_roberts));
title("Blood Roberts 边缘检测");

subplot(2, 4, 3);
imshow((blood_sobel));
title("Blood Sobel 边缘检测");

subplot(2, 4, 4);
imshow((blood_prewitt));
title("Blood Prewitt 边缘检测");


subplot(2, 4, 5);
imshow(blood);
title("Blood 原始图");

subplot(2, 4, 6);
imshow(blood_laplacian_1);
title("Blood Laplacian 边缘检测 1");

subplot(2, 4, 7);
imshow(blood_laplacian_2);
title("Blood Laplacian 边缘检测 2");

subplot(2, 4, 8);
imshow((blood_canny));
title("Blood Canny 边缘检测");
```

```matlab
clc;
clear;
close all;

% This is the lab for digital image courses
% Task 3 PART IV
% edge 

lena = imread("./pics/lena.bmp");
[m, n] = size(lena);

lena_roberts = edge(lena, 'Roberts');
lena_sobel = edge(lena, 'Sobel');
lena_prewitt = edge(lena, 'Prewitt');
lena_canny = edge(lena, 'Canny');


filter_laplacian_1 = [0 1 0; 1 -4 1; 0 1 0];
filter_laplacian_2 = [-1 -1 -1; -1 8 -1; -1 -1 -1];

lena_laplacian_1 = imfilter(lena, filter_laplacian_1);
lena_laplacian_2 = imfilter(lena, filter_laplacian_2);

figure();
subplot(2, 4, 1);
imshow(lena);
title("Lena 原始图");

subplot(2, 4, 2);
imshow((lena_roberts));
title("Lena Roberts 边缘检测");

subplot(2, 4, 3);
imshow((lena_sobel));
title("Lena Sobel 边缘检测");

subplot(2, 4, 4);
imshow((lena_prewitt));
title("Lena Prewitt 边缘检测");


subplot(2, 4, 5);
imshow(lena);
title("Lena 原始图");

subplot(2, 4, 6);
imshow(lena_laplacian_1);
title("Lena Laplacian 边缘检测 1");

subplot(2, 4, 7);
imshow(lena_laplacian_2);
title("Lena Laplacian 边缘检测 2");

subplot(2, 4, 8);
imshow((lena_canny));
title("Lena Canny 边缘检测");
```

##### 用到的函数

- edge (I) : 返回二值图像 BW，其中的值 1 对应于灰度或二值图像 I 中函数找到边缘的位置，值 0 对应于其他位置。默认情况下，edge 使用 Sobel 边缘检测方法。

##### 结果展示

![image-20220502184002230](pics\3-3.png)

![image-20220502184034305](pics\3-4.png)





### 实验四 图像变换及频域滤波增强

**实验内容及实验原理：**

​		掌握 Fourier 变换、反变换的算法实现，并验证 Fourier 变换的性质，初步理解 Fourier变换的物理意义。掌握频域空间的各种滤波器。

1.  用 Fourier 变换算法对图像作二维 Fourier 变换。
2.  用 Fourier 反变换算法对图像作二维 Fourier 反变换。
3.  评价人眼对图像幅度特性和相位特性的敏感度。
4.  设计频域平滑滤波器，对图像进行滤波。
5.  设计频域锐化滤波器，对图像进行滤波。

**要求：**